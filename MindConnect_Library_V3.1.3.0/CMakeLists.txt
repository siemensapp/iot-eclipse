CMAKE_MINIMUM_REQUIRED(VERSION 3.5 FATAL_ERROR)

#Set verbose mode for make process
SET(CMAKE_VERBOSE_MAKEFILE ON)

#Project name 
PROJECT(MindConnectLibrary VERSION "03.01.03.00" LANGUAGES C)
MESSAGE(STATUS "MCL Version = ${PROJECT_VERSION}")
SET(CMAKE_C_STANDARD 99)
SET(CMAKE_C_STANDARD_REQUIRED ON)

#Required CURL and OpenSSL versions
SET(CURL_VERSION_REQUIRED 7.50.1)
SET(OPENSSL_VERSION_NUMBER_REQUIRED 1.0.2)
SET(OPENSSL_VERSION_LETTER_REQUIRED "j")

#Set MCL_SOURCES to collect source files from different locations
SET(MCL_SOURCES "" CACHE INTERNAL "MCL_SOURCES" FORCE)
SET(MCL_LIBS "" CACHE INTERNAL "MCL_LIBS" FORCE)
SET(MCL_INCLUDE_DIRECTORIES "" CACHE INTERNAL "MCL_INCLUDE_DIRECTORIES" FORCE)

#Set path of MCL's root Cmake directory
SET(MCL_CMAKE_ROOT_DIR ${CMAKE_CURRENT_SOURCE_DIR})

INCLUDE(CheckIncludeFile)

#Check for header files
CHECK_INCLUDE_FILE("stdio.h" HAVE_STDIO_H_)
CHECK_INCLUDE_FILE("stddef.h" HAVE_STDDEF_H_)
CHECK_INCLUDE_FILE("string.h" HAVE_STRING_H_)
CHECK_INCLUDE_FILE("stdlib.h" HAVE_STDLIB_H_)
CHECK_INCLUDE_FILE("stdint.h" HAVE_STDINT_H_)
CHECK_INCLUDE_FILE("stdarg.h" HAVE_STDARG_H_)
CHECK_INCLUDE_FILE("syslog.h" HAVE_SYSLOG_H_)
CHECK_INCLUDE_FILE("time.h" HAVE_TIME_H_)

LIST(APPEND STANDARD_HEADER_MACROS HAVE_STDIO_H_ HAVE_STDDEF_H_ HAVE_STRING_H_ HAVE_STDLIB_H_ HAVE_STDINT_H_ HAVE_STDARG_H_ HAVE_TIME_H_)
FOREACH(STANDARD_HEADER_MACRO ${STANDARD_HEADER_MACROS})
    STRING(REPLACE "HAVE_" "" STANDARD_HEADER_FILE ${STANDARD_HEADER_MACRO})
    STRING(REPLACE "_H_" ".H" STANDARD_HEADER_FILE ${STANDARD_HEADER_FILE})  
    IF(${STANDARD_HEADER_MACRO})
        MESSAGE(STATUS "Standard header ${STANDARD_HEADER_FILE} is found.")  
    ELSE()
        MESSAGE(FATAL_ERROR "FATAL ERROR : Build process terminated because ${STANDARD_HEADER_FILE} is NOT found.")     
    ENDIF()    
ENDFOREACH()

#Option to mark that MCL is build
OPTION(MCL_BUILD "Option to mark that MCL is build. This option is required e.g. to include mcl_exports or not." ON)
IF(MCL_BUILD)
	MESSAGE(STATUS "MCL build is ${MCL_BUILD}.")
	ADD_DEFINITIONS(-DMCL_BUILD=1)
ENDIF()

#Option to set if MCL build as static or dynamic
OPTION(MCL_STATICLIB "Option to set if MCL build as static or dynamic." OFF)
IF(MCL_STATICLIB)
	SET(MCL_USER_DEFINED_DYNAMIC_OR_STATIC STATIC)
	ADD_DEFINITIONS(-DMCL_STATICLIB=1)
ELSE()
	SET(MCL_USER_DEFINED_DYNAMIC_OR_STATIC SHARED)
	ADD_DEFINITIONS(-DMCL_STATICLIB=0)
ENDIF()
MESSAGE(STATUS "MCL will be build as ${MCL_USER_DEFINED_DYNAMIC_OR_STATIC} library.")

#Option to enable or disable use of Libcurl
OPTION(MCL_USE_LIBCURL "Use Libcurl for HTTPS." ON)

#Check for OpenSSL
OPTION(MCL_USE_OPENSSL "Use OpenSSL code." ON)
OPTION(CMAKE_USE_OPENSSL "Use OpenSSL code." ${MCL_USE_OPENSSL})

FIND_PROGRAM(RUBY_FOUND ruby)
IF(RUBY_FOUND)
	#Option to enable or disable testing of MCL
	OPTION(MCL_TESTING "Enable testing of MCL." ON)
	MESSAGE(STATUS "Ruby found on path (${RUBY_FOUND}) and MCL testing is ${MCL_TESTING}.")
ELSE()
	MESSAGE(STATUS "Ruby not found on path. Skipping MCL testing...")
	OPTION(MCL_TESTING "Enable testing of MCL." OFF)
ENDIF()

FIND_PROGRAM(DOXYGEN_FOUND doxygen)
IF(DOXYGEN_FOUND)
	#Option to enable or disable creation of doxygen
	OPTION(MCL_CREATE_DOXYGEN "Enable creation of doxygen." ON)
	MESSAGE(STATUS "Doxygen found on path (${DOXYGEN_FOUND}) and document creation is ${MCL_CREATE_DOXYGEN}.")
ELSE()
	MESSAGE(STATUS "Doxygen not found on path. Skipping creation of documents...")
	OPTION(MCL_CREATE_DOXYGEN "Enable creation of doxygen." OFF)
ENDIF()

#Define storage medium and file system presence on the target
OPTION(HAVE_FILE_SYSTEM_ "The target has a file system." ON)
OPTION(HAVE_STORAGE_MEDIUM_ "The target has a storage medium." ON)

IF(MCL_USE_OPENSSL)
    FIND_PACKAGE(OpenSSL)
    IF(OPENSSL_FOUND)
		
		#Verify OpenSSL version	
		STRING(REGEX MATCH "[0-9]+[.][0-9]+[.][0-9]+" OPENSSL_VERSION_NUMBER ${OPENSSL_VERSION})
		STRING(REGEX MATCH "[a-z]+" OPENSSL_VERSION_LETTER ${OPENSSL_VERSION})
		IF((OPENSSL_VERSION_NUMBER VERSION_LESS OPENSSL_VERSION_NUMBER_REQUIRED) OR 
		   ((OPENSSL_VERSION_NUMBER VERSION_EQUAL OPENSSL_VERSION_NUMBER_REQUIRED) AND 
		    (OPENSSL_VERSION_LETTER STRLESS OPENSSL_VERSION_LETTER_REQUIRED)))
			MESSAGE(FATAL_ERROR "Found OpenSSL version ${OPENSSL_VERSION} but version ${OPENSSL_VERSION_NUMBER_REQUIRED}${OPENSSL_VERSION_LETTER_REQUIRED} or later is required.")
		ELSE()  
			SET(MCL_HAVE_OPENSSL ON)
			SET(CMAKE_REQUIRED_INCLUDES ${OPENSSL_INCLUDE_DIR})
			CHECK_INCLUDE_FILE("openssl/rsa.h" HAVE_OPENSSL_RSA_H_)
			CHECK_INCLUDE_FILE("openssl/md5.h" HAVE_OPENSSL_MD5_H_)
			CHECK_INCLUDE_FILE("openssl/sha.h" HAVE_OPENSSL_SHA_H_)
			CHECK_INCLUDE_FILE("openssl/ssl.h" HAVE_OPENSSL_SSL_H_)
			CHECK_INCLUDE_FILE("openssl/crypto.h" HAVE_OPENSSL_CRYPTO_H_)
			CHECK_INCLUDE_FILE("openssl/rand.h" HAVE_OPENSSL_RAND_H_)
			CHECK_INCLUDE_FILE("openssl/bn.h" HAVE_OPENSSL_BN_H_)
			CHECK_INCLUDE_FILE("openssl/bio.h" HAVE_OPENSSL_BIO_H_)
			CHECK_INCLUDE_FILE("openssl/pem.h" HAVE_OPENSSL_PEM_H_)
			
			MESSAGE(STATUS "Using OpenSSL   = " ${MCL_HAVE_OPENSSL} " (Version ${OPENSSL_VERSION})")
			MESSAGE(STATUS "    includes    = " ${OPENSSL_INCLUDE_DIR})
			MESSAGE(STATUS "    libraries   = " ${OPENSSL_LIBRARIES})
			MESSAGE(STATUS "    have RSA    = " ${HAVE_OPENSSL_RSA_H_})
			MESSAGE(STATUS "    have MD5    = " ${HAVE_OPENSSL_MD5_H_})
			MESSAGE(STATUS "    have SHA    = " ${HAVE_OPENSSL_SHA_H_})
			MESSAGE(STATUS "    have SSL    = " ${HAVE_OPENSSL_SSL_H_})
			MESSAGE(STATUS "    have Crypto = " ${HAVE_OPENSSL_CRYPTO_H_})
            MESSAGE(STATUS "    have Rand   = " ${HAVE_OPENSSL_RAND_H_})
			MESSAGE(STATUS "    have BN     = " ${HAVE_OPENSSL_BN_H_})
        	MESSAGE(STATUS "    have BIO    = " ${HAVE_OPENSSL_BIO_H_})
        	MESSAGE(STATUS "    have PEM    = " ${HAVE_OPENSSL_PEM_H_})
        
			LIST(APPEND MCL_LIBS ${OPENSSL_LIBRARIES})
			LIST(APPEND MCL_INCLUDE_DIRECTORIES ${OPENSSL_INCLUDE_DIR})        
			SET(MCL_INCLUDE_DIRECTORIES ${MCL_INCLUDE_DIRECTORIES} CACHE INTERNAL "MCL_INCLUDE_DIRECTORIES" FORCE)
			SET(MCL_LIBS ${MCL_LIBS} CACHE INTERNAL "MCL_LIBS" FORCE)
		ENDIF()
    ELSE()
        SET(MCL_HAVE_OPENSSL OFF)
        MESSAGE(STATUS "OpenSSL not found")
    ENDIF()
ELSE()
	MESSAGE(STATUS "Use of OpenSSL disabled.")
ENDIF()

#Set log level if provided during call of cmake
IF(MCL_LOG_UTIL_LEVEL)
	MESSAGE(STATUS "Compile log level set to ${MCL_LOG_UTIL_LEVEL}")
	ADD_DEFINITIONS(-DMCL_LOG_UTIL_LEVEL=${MCL_LOG_UTIL_LEVEL})
ENDIF()

#Set flags for coverage output
STRING(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_LOWER)
IF(CMAKE_COMPILER_IS_GNUCC AND (CMAKE_BUILD_TYPE_LOWER MATCHES debug))
    MESSAGE(STATUS "Coverage output with GNU CC generated")
    SET(GCC_COVERAGE_COMPILE_FLAGS "-fprofile-arcs -ftest-coverage")
    SET(GCC_COVERAGE_LINK_FLAGS "-lgcov")
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${GCC_COVERAGE_COMPILE_FLAGS}")
    SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${GCC_COVERAGE_LINK_FLAGS}")
ENDIF()

#Use solution folders.
SET_PROPERTY(GLOBAL PROPERTY USE_FOLDERS ON)

#Set output folder for all targets
#First for the generic no-config case (e.g. with mingw)
SET(MCL_OUTPUT_DIR ${CMAKE_BINARY_DIR}/build/${CMAKE_BUILD_TYPE})
SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${MCL_OUTPUT_DIR})
SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${MCL_OUTPUT_DIR})
SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${MCL_OUTPUT_DIR})
#Second, for multi-config builds (e.g. msvc)
FOREACH(OUTPUTCONFIG ${CMAKE_CONFIGURATION_TYPES})
    STRING(TOUPPER ${OUTPUTCONFIG} OUTPUTCONFIG)
    SET(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${MCL_OUTPUT_DIR})
    SET(CMAKE_LIBRARY_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${MCL_OUTPUT_DIR})
    SET(CMAKE_RUNTIME_OUTPUT_DIRECTORY_${OUTPUTCONFIG} ${MCL_OUTPUT_DIR})
ENDFOREACH()

#Find CURL
IF(MCL_USE_LIBCURL)
    FIND_PACKAGE(CURL)
    IF(CURL_FOUND)
        #Check version
        IF(CURL_VERSION_STRING VERSION_LESS CURL_VERSION_REQUIRED)
            MESSAGE(FATAL_ERROR "Found CURL version ${CURL_VERSION_STRING} but version ${CURL_VERSION_REQUIRED} is required.")
        ELSE()
            MESSAGE(STATUS "Found CURL version ${CURL_VERSION_STRING}.")
    	ENDIF()
        
        #Add CURL library to the list of MCL libraries to be linked
    	LIST(APPEND MCL_LIBS ${CURL_LIBRARIES})
    	
    	#Add CURL include directory to the list of include directories of MCL
    	LIST(APPEND MCL_INCLUDE_DIRECTORIES ${CURL_INCLUDE_DIRS})        
    	
    	#Update MCL_INCLUDE_DIRECTORIES and MCL_LIBS
    	SET(MCL_INCLUDE_DIRECTORIES ${MCL_INCLUDE_DIRECTORIES} CACHE INTERNAL "MCL_INCLUDE_DIRECTORIES" FORCE)
    	SET(MCL_LIBS ${MCL_LIBS} CACHE INTERNAL "MCL_LIBS" FORCE)			
    ELSE()
        MESSAGE(FATAL_ERROR "Not found CURL!")
    ENDIF()    
ELSE()
	MESSAGE(STATUS "Use of Libcurl disabled.")
ENDIF()

#Copy required libs to output folder
IF(WIN32 OR WIN64)
    MESSAGE(STATUS "MCL_LIBS = ${MCL_LIBS}")
    FOREACH(MCL_LIB ${MCL_LIBS})
		STRING(REPLACE ".lib" ".dll" MCL_LIB ${MCL_LIB})
		STRING(REPLACE "lib/libcurl_imp" "bin/libcurl" MCL_LIB ${MCL_LIB})		
        IF(EXISTS ${MCL_LIB})
			MESSAGE(STATUS "    Copying ${MCL_LIB} to ${MCL_OUTPUT_DIR}")
			FILE(COPY ${MCL_LIB} DESTINATION ${MCL_OUTPUT_DIR})
		ENDIF()
    ENDFOREACH()
ENDIF()

ADD_SUBDIRECTORY(lib/cJSON)
ADD_SUBDIRECTORY(lib/zf_log)

#MCL Core sources
ADD_SUBDIRECTORY(src)

IF(MCL_TESTING)
	# Turn on CMake testing capabilities
	ENABLE_TESTING()
	ADD_SUBDIRECTORY(test)
ELSE()	
	MESSAGE(STATUS "Testing of MCL is disabled.")
ENDIF()

#Doxygen
IF(MCL_CREATE_DOXYGEN)
	ADD_SUBDIRECTORY(doc)
	ADD_DEPENDENCIES(mc mcl_doc create_zip)	
ELSE()
	MESSAGE(STATUS "Creation of doxygen documentation is disabled.")
ENDIF()

#Set variables for distribution package destination
SET(PACKAGE_DESTINATION_BIN "bin")
SET(PACKAGE_DESTINATION_INCLUDE "include")
SET(PACKAGE_DESTINATION_LIB "lib")

SET(CPACK_ARCHIVE_COMPONENT_INSTALL ON)
SET(BINARY_COMPONENT_NAME "binary")
SET(SOURCE_COMPONENT_NAME "source")
       
#Install directory for the header files
INSTALL(DIRECTORY "${MCL_CMAKE_ROOT_DIR}/include/mcl" DESTINATION ${PACKAGE_DESTINATION_INCLUDE} COMPONENT ${BINARY_COMPONENT_NAME})

#Install README document
INSTALL(FILES "${MCL_CMAKE_ROOT_DIR}/README.md" DESTINATION . COMPONENT ${BINARY_COMPONENT_NAME})

#Install OpenSSL libraries if they are found
IF(OPENSSL_FOUND)    
    IF(WIN32 OR WIN64)
        FOREACH(OPENSSL_LIB ${OPENSSL_LIBRARIES})
    		STRING(REPLACE ".lib" ".dll" OPENSSL_LIB ${OPENSSL_LIB})
            IF(EXISTS ${OPENSSL_LIB})
    			INSTALL(FILES ${OPENSSL_LIB} DESTINATION ${PACKAGE_DESTINATION_BIN} COMPONENT ${BINARY_COMPONENT_NAME})
    		ENDIF()
        ENDFOREACH()
    ELSE()
        INSTALL(FILES ${OPENSSL_LIBRARIES} DESTINATION ${PACKAGE_DESTINATION_LIB} COMPONENT ${BINARY_COMPONENT_NAME})    
    ENDIF()
ENDIF()

#Install top directory for source distribution
INSTALL(DIRECTORY "${MCL_CMAKE_ROOT_DIR}" DESTINATION . COMPONENT ${SOURCE_COMPONENT_NAME})

#Set CPack configuration        
SET(CPACK_GENERATOR "ZIP")
SET(CPACK_PACKAGE_NAME "MCL")
SET(CPACK_PACKAGE_VERSION "${PROJECT_VERSION}")
SET(CPACK_OUTPUT_FILE_PREFIX ${CMAKE_BINARY_DIR}/dist)

SET(CPACK_COMPONENTS_ALL ${SOURCE_COMPONENT_NAME} ${BINARY_COMPONENT_NAME})
                                  
#Include CPack to create 'package' target
INCLUDE(CPack)
