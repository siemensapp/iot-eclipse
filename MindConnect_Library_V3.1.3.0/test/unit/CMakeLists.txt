#Set name of the test framework.
SET(TEST_FRAMEWORK unity_and_cmock)

#Set paths.
SET(MOCK_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/mock")
SET(TEST_CASE_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}")
SET(TEST_RUNNER_DIRECTORY "${CMAKE_CURRENT_BINARY_DIR}/testrunner")
SET(GENERATE_TEST_RUNNER_SCRIPT_PATH "test/lib/CMock/vendor/unity/auto/generate_test_runner.rb")
SET(TEST_TYPE "unit")

#Create mock and test runner directories.
FILE(MAKE_DIRECTORY ${MOCK_DIRECTORY})
FILE(MAKE_DIRECTORY ${TEST_RUNNER_DIRECTORY})

#Clean Mock Directory
FILE(GLOB MOCK_DIRECTORY_OLD_FILES "${MOCK_DIRECTORY}/*")
IF(MOCK_DIRECTORY_OLD_FILES)
	FILE(REMOVE ${MOCK_DIRECTORY_OLD_FILES})
ENDIF()

#Create mocks for headers in src folder.
SET(RUBY_CMD "ruby")
SET(RUBY_SCRIPT_PATH "test/lib/CMock/lib/cmock.rb")
SET(CMOCK_YML_FILE_INPUT "cmock.yml.in")
SET(CMOCK_YML_FILE "${CMAKE_CURRENT_BINARY_DIR}/cmock.yml")
SET(CMOCK_YML_INCLUDES "")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
FILE(GLOB HEADERS_TO_MOCK "${MCL_CMAKE_ROOT_DIR}/src/*.h")
SET(MOCK_HTTP_CLIENT_H "${MCL_CMAKE_ROOT_DIR}/src/http_client.h")
SET(MOCK_TIME_SERIES_H "${MCL_CMAKE_ROOT_DIR}/src/time_series.h")
SET(MOCK_MCL_TIME_SERIES_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_time_series.h")
SET(MOCK_MCL_CUSTOM_DATA_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_custom_data.h")
SET(MOCK_MCL_STREAM_DATA_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_stream_data.h")
SET(MOCK_MCL_EVENT_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_event.h")
#SET(MOCK_MCL_JOB_CONFIGURATION_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_job_configuration.h")
#SET(MOCK_MCL_JOB_FIRMWARE_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_job_firmware.h")
SET(MOCK_MCL_DATA_SOURCE_CONFIGURATION_H "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_data_source_configuration.h")
LIST(REMOVE_ITEM HEADERS_TO_MOCK ${MOCK_HTTP_CLIENT_H} ${MOCK_TIME_SERIES_H})

EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${HEADERS_TO_MOCK}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)

#Configure yml and create mock for headers in include folder. The mocks header will also include the corresponding header in src folder (e.g. to include typedef/structs).
FILE(GLOB INCLUDE_HEADERS_TO_MOCK "${MCL_CMAKE_ROOT_DIR}/include/mcl/*.h")
FOREACH(INCLUDE_HEADER_TO_MOCK ${INCLUDE_HEADERS_TO_MOCK})
    #only consider headers : include/mcl/mcl_*.h
    IF(INCLUDE_HEADER_TO_MOCK MATCHES "^.*mcl_[a-zA-Z_]*\\.h$")
        STRING(REGEX REPLACE "^(.*)mcl_" "" SOURCE_HEADER_TO_INCLUDE ${INCLUDE_HEADER_TO_MOCK})
        #if src/*.h doesnt exist dont include in mock-header
        IF(EXISTS "${MCL_CMAKE_ROOT_DIR}/src/${SOURCE_HEADER_TO_INCLUDE}")
            SET(CMOCK_YML_INCLUDES "[${SOURCE_HEADER_TO_INCLUDE}]")
        ELSE()
            SET(CMOCK_YML_INCLUDES "")
        ENDIF()
        #MESSAGE(STATUS "Creating mock for ${INCLUDE_HEADER_TO_MOCK} with include of ${SOURCE_HEADER_TO_INCLUDE}")
        CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
        EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${INCLUDE_HEADER_TO_MOCK}
            WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
            RESULT_VARIABLE ruby_result	
            OUTPUT_VARIABLE ruby_output)
     ENDIF()
ENDFOREACH()

#Configure yml and create mock for http_client with type definition from libcurl implementation.
SET(CMOCK_YML_INCLUDES "[http_client_libcurl.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_HTTP_CLIENT_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)
    
SET(CMOCK_YML_INCLUDES "[time_series.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_TIME_SERIES_H} ${MOCK_MCL_TIME_SERIES_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)

SET(CMOCK_YML_INCLUDES "[custom_data.h, json_util.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_CUSTOM_DATA_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)

SET(CMOCK_YML_INCLUDES "[stream_data.h, json_util.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_STREAM_DATA_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)

SET(CMOCK_YML_INCLUDES "[event.h, json_util.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_EVENT_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)
    
#SET(CMOCK_YML_INCLUDES "[communication.h]")
#CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
#EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_JOB_CONFIGURATION_H}
#    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#    RESULT_VARIABLE ruby_result	
#    OUTPUT_VARIABLE ruby_output)
    
#SET(CMOCK_YML_INCLUDES "[communication.h]")
#CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
#EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_JOB_FIRMWARE_H}
#    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
#    RESULT_VARIABLE ruby_result	
#    OUTPUT_VARIABLE ruby_output)  
    
SET(CMOCK_YML_INCLUDES "[json_util.h, data_source_configuration.h]")
CONFIGURE_FILE(${CMOCK_YML_FILE_INPUT} ${CMOCK_YML_FILE})
EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${RUBY_SCRIPT_PATH} -o${CMOCK_YML_FILE} ${MOCK_MCL_DATA_SOURCE_CONFIGURATION_H}
    WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
    RESULT_VARIABLE ruby_result	
    OUTPUT_VARIABLE ruby_output)  
        
#Set test libraries
SET(TEST_LIBS ${MCL_LIBS} ${TEST_FRAMEWORK})

#Set mock sources
FILE(GLOB MOCK_SOURCES "${MOCK_DIRECTORY}/*.c")

#Set mock library
SET(MOCK_LIB MOCK_SOURCES)
ADD_LIBRARY(${MOCK_LIB} ${MOCK_SOURCES})
TARGET_LINK_LIBRARIES(${MOCK_LIB} ${TEST_LIBS})
TARGET_INCLUDE_DIRECTORIES(${MOCK_LIB} PUBLIC ${MCL_INCLUDE_DIRECTORIES} ${MCL_CMAKE_ROOT_DIR}/include/mcl)

#PIC option is required in order to build MOCK_LIB with shared library target
SET_TARGET_PROPERTIES(${MOCK_LIB} PROPERTIES POSITION_INDEPENDENT_CODE ON)

#Append mock library to test libraries
LIST(APPEND TEST_LIBS ${MOCK_LIB})

#Loop over each unit test file.
FILE(GLOB UNIT_TEST_FILE_LIST RELATIVE "${TEST_CASE_DIRECTORY}" "${TEST_CASE_DIRECTORY}/*.c") 
FOREACH(UNIT_TEST_FILE ${UNIT_TEST_FILE_LIST})

    #Remove file extension from the testcase file
    STRING(REPLACE ".c" "" UNIT_TEST_FILE_NAME ${UNIT_TEST_FILE})
                 
    #Create test runner.
    SET(TEST_RUNNER_FILE "${UNIT_TEST_FILE_NAME}_runner.c")
    EXECUTE_PROCESS(COMMAND ${RUBY_CMD} ${GENERATE_TEST_RUNNER_SCRIPT_PATH} "${TEST_CASE_DIRECTORY}/${UNIT_TEST_FILE}" "${TEST_RUNNER_DIRECTORY}/${TEST_RUNNER_FILE}"
        WORKING_DIRECTORY ${PROJECT_SOURCE_DIR}
        RESULT_VARIABLE ruby_result	
        OUTPUT_VARIABLE ruby_output)
    
    #Set original source files. 
    SET(ORIGINAL_SOURCES "")
    FILE(STRINGS "${TEST_CASE_DIRECTORY}/${UNIT_TEST_FILE}" INCLUDE_LINE_LIST REGEX "^#include*")     
    FOREACH(INCLUDE_LINE ${INCLUDE_LINE_LIST})
        STRING(REPLACE "#include \"" "" INCLUDE_FILE_H_ ${INCLUDE_LINE})
        STRING(REGEX REPLACE "\".*" "" INCLUDE_FILE_H_ ${INCLUDE_FILE_H_}) 
        STRING(REGEX REPLACE ".*/" "" INCLUDE_FILE_H_ ${INCLUDE_FILE_H_})
        STRING(REPLACE ".h" ".c" INCLUDE_FILE_C_ ${INCLUDE_FILE_H_})
        IF(EXISTS "${MCL_CMAKE_ROOT_DIR}/src/${INCLUDE_FILE_H_}")
            LIST(REMOVE_ITEM MOCK_SOURCES "${MOCK_DIRECTORY}/mock_${INCLUDE_FILE_C_}")
            IF(EXISTS "${MCL_CMAKE_ROOT_DIR}/src/${INCLUDE_FILE_C_}")
                LIST(APPEND ORIGINAL_SOURCES "${MCL_CMAKE_ROOT_DIR}/src/${INCLUDE_FILE_C_}")
            ENDIF() 
        ELSEIF(EXISTS "${MCL_CMAKE_ROOT_DIR}/include/mcl/mcl_${INCLUDE_FILE_H_}")
            LIST(REMOVE_ITEM MOCK_SOURCES "${MOCK_DIRECTORY}/mock_${INCLUDE_FILE_C_}")
            IF(EXISTS "${MCL_CMAKE_ROOT_DIR}/src/${INCLUDE_FILE_C_}")
                LIST(APPEND ORIGINAL_SOURCES "${MCL_CMAKE_ROOT_DIR}/src/${INCLUDE_FILE_C_}")
            ENDIF() 
        ENDIF()
    ENDFOREACH(INCLUDE_LINE) 

    #Set test source files.             
    SET(TEST_SOURCES ${TEST_CASE_DIRECTORY}/${UNIT_TEST_FILE} ${TEST_RUNNER_DIRECTORY}/${TEST_RUNNER_FILE})

    #Set the name of the test executable.   
    SET(UNIT_TEST_EXECUTABLE ${UNIT_TEST_FILE_NAME})

    #Create test executable.    
    ADD_EXECUTABLE(${UNIT_TEST_EXECUTABLE} $<TARGET_OBJECTS:zf_log> $<TARGET_OBJECTS:cJSON> ${TEST_SOURCES} ${ORIGINAL_SOURCES})    
        
    #Link libraries to executable.
    TARGET_LINK_LIBRARIES(${UNIT_TEST_EXECUTABLE} ${TEST_LIBS})

	#Set linker flag -lm for linking against the math lib (pow() floor())
	IF(CMAKE_COMPILER_IS_GNUCC)
		TARGET_LINK_LIBRARIES(${UNIT_TEST_EXECUTABLE} m)
	ENDIF()

    #Include required directories
    TARGET_INCLUDE_DIRECTORIES(${UNIT_TEST_EXECUTABLE} PUBLIC ${MOCK_DIRECTORY})
    TARGET_INCLUDE_DIRECTORIES(${UNIT_TEST_EXECUTABLE} PUBLIC ${MCL_INCLUDE_DIRECTORIES})
	
	SET_TARGET_PROPERTIES(${UNIT_TEST_EXECUTABLE} PROPERTIES
		FOLDER "${TEST_TYPE}_tests")

    ADD_TEST(${UNIT_TEST_EXECUTABLE} ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${UNIT_TEST_EXECUTABLE})
    
ENDFOREACH(UNIT_TEST_FILE) 
