/*!**********************************************************************
 *
 * @copyright Copyright (C) 2016 Siemens Aktiengesellschaft.\n
 *            All rights reserved.
 *
 *************************************************************************
 *
 * @file     security_handler.h
 * @date     Jun 27, 2016
 * @brief    Security handler module header file.
 *
 * This module presents security related operations. Used by upper layer modules. Works as an intermediate layer between upper
 * level modules and underlying implementations. For actual security operation implementations please check security.h
 *
 ************************************************************************/

#ifndef SECURITY_HANDLER_H_
#define SECURITY_HANDLER_H_

#include "string_type.h"

/**
 * @brief RSA Pair Struct holding public and private and session keys
 */
typedef struct rsa_t
{
    char *public_key;              //!< Public key.
    mcl_size_t public_key_length;  //!< Public key length.
    char *private_key;             //!< Private key.
    mcl_size_t private_key_length; //!< Private key length.
    mcl_uint8_t *session_key;      //!< Session key.
    mcl_size_t session_key_length; //!< Session key length.
} rsa_t;

/**
 * @brief Handle struct for security_handler module.
 *
 * Holds rsa public private key pair (rsa),
 * authentication key generated by HMAC algorithm (hmac_key),
 * onboarding key (onboarding_key) and
 * authentication key (authentication_key) with its size (authentication_key_size).
 */
typedef struct security_handler_t
{
    rsa_t rsa;                           //!< Rsa handle.
    mcl_uint8_t *hmac_key;               //!< Hmac key.
    mcl_uint8_t *onboarding_key;         //!< Onboarding key.
    mcl_uint8_t *authentication_key;     //!< Authentication key.
    mcl_size_t authentication_key_size;  //!< Size of authentication key.
    string_t *registration_access_token; //!< Registration access token.
    string_t *registration_client_uri;   //!< Registration client uri.
    string_t *client_secret;             //!< Client secret.
    string_t *access_token;              //!< Access token.
	string_t *last_token_time;			 //!< The time at which the last access token is received.
    string_t *client_id;                 //!< Client id.
} security_handler_t;

/**
 * @brief Initializer of security handler.
 *
 * @param [out] security_handler Handle to be created and initialized.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_initialize(security_handler_t **security_handler);

/**
 * @brief To be used to generate the jti nonce.
 *
 * This generated jti nonce will be used inside of the authentication JWT.
 *
 * @param [out] jti Generated jti string : 128 bit random number, base64 encoded.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of failure.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_generate_jti(string_t **jti);

/**
 * @brief To be used to generate the sha256 hash of the given data.
 *
 * @param [in] data Data to be hashed.
 * @param [in] data_size Size of @p data.
 * @param [out] hash Generated hash result.
 * @param [out] hash_size Length of the generated @p hash.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_hash_sha256(const mcl_uint8_t *data, mcl_size_t data_size, mcl_uint8_t **hash, mcl_size_t *hash_size);

/**
 * Calculates HMAC SHA256 for given data with the authorization key of provided @p security_handler.
 *
 * @param [in] security_handler Security handler to use its authorization key.
 * @param [in] data Data to calculate HMAC SHA256 for.
 * @param [in] data_size Size of @p data.
 * @param [out] hash A newly allocated memory which contains the result of HMAC SHA256.
 * @param [out] hash_size Size of @p hash, which should be 32 bytes after SHA256 calculation.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_INVALID_PARAMETER if key_size of @p security_handler is zero.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_SHA256_CALCULATION_FAIL if SHA256 calculation fails.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_hmac_sha256(security_handler_t *security_handler, const mcl_uint8_t *data, mcl_size_t data_size, mcl_uint8_t **hash, mcl_size_t *hash_size);

/**
 * @brief To be used to encode the given data in base64 URL encoding format.
 *
 * @param [in] data Data to be encoded.
 * @param [in] data_size Data size.
 * @param [out] encoded_data Encoded result.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_base64_url_encode(const mcl_uint8_t *data, mcl_size_t data_size, string_t **encoded_data);

/**
 * @brief To be used to encode the given data in base64 encoding format.
 *
 * @param [in] data Data to be encoded.
 * @param [in] data_size Data size.
 * @param [out] encoded_data Encoded result.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_base64_encode(const mcl_uint8_t *data, mcl_size_t data_size, string_t **encoded_data);

/**
 * Given a base64 zero-terminated string at @p encoded_data, decode it and return a
 * pointer in @p decoded_data to a newly allocated memory area holding decoded
 * data. Size of decoded data is returned in variable pointed by @p decoded_data_size.
 *
 * When decoded data length is 0, returns #MCL_NULL in @p decoded_data.
 *
 * @param encoded_data [in] Zero-terminated string which is base64 encoded and has to be decoded.
 * @param decoded_data [out] Newly allocated memory holding decoded data.
 * @param decoded_data_size [out] Size of decoded data.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_BAD_CONTENT_ENCODING if provided @p encoded_data has invalid length (0 or not multiples of 4) or if the given @p encoded_data is invalidly encoded.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_base64_decode(const string_t *encoded_data, mcl_uint8_t **decoded_data, mcl_size_t *decoded_data_size);

/**
 * @brief To be used to generate the RSA public/private key pairs.
 *
 * Generated key pairs will be stored in the received handler.
 *
 * @param [in] security_handler Handler to be used.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of an internal error in MCL.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_generate_rsa_key(security_handler_t *security_handler);

/**
 * @brief To be used to sign data with RSA key.
 *
 * Received key will be used to sign. Caller can use the generated RSA private key or the servers public key.
 *
 * @param [in] rsa_key The key to be used in signing.
 * @param [in] data The data to be signed.
 * @param [in] data_size Size of the data.
 * @param [out] signature Generated signature.
 * @param [out] signature_size Size of signature.
 * @return
 * <ul>
 * <li>#MCL_OK in case of success.</li>
 * <li>#MCL_OUT_OF_MEMORY in case there is not enough memory in the system to proceed.</li>
 * <li>#MCL_FAIL in case of an internal error in MCL.</li>
 * </ul>
 */
E_MCL_ERROR_CODE security_handler_rsa_sign(char *rsa_key, char *data, mcl_size_t data_size, mcl_uint8_t **signature, mcl_size_t *signature_size);

/**
 * @brief To destroy the Security Handler.
 *
 * Will release the resources of security handler. After destroy operation, handler shouldn't be used.
 * @param [in] security_handler Handler to be destroyed.
 */
void security_handler_destroy(security_handler_t **security_handler);

#endif //SECURITY_HANDLER_H_
